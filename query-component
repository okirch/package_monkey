#!/usr/bin/python3

from options import Application
from filter import Classification, PackageFilter
from util import IndexFormatter, IndexFormatterTwoLevels, CountingDict
from queries import QueryContext, QuerySubjectComponent, QuerySubjectComponentOrTopic
from queries import PackageRequiresLabelsPredicate, RequirementsReport, BuildRequirementsReport
from csvio import CSVWriter

class QueryApplication(Application):
	def __init__(self, name, *args, **kwargs):
		super().__init__(name, *args, **kwargs)

		self.addArgument(dest = 'components', metavar = 'COMPONENTS', nargs = '*', help = 'list of labels to query')
		self.addArgument('--imports', action = 'store_true', default = False)
		self.addArgument('--terse', action = 'store_true', default = False)
		self.addArgument('--verbose', action = 'store_true', default = False)
		self.addArgument('--list', action = 'store_true', default = False)
		self.addArgument('--requires', action = 'store_true', default = False)
		self.addArgument('--what-requires', action = 'append', default = [])
		self.addArgument('--what-build-requires', action = 'append', default = [])
		self.addArgument('--unclassified', action = 'store_true', default = False)
		self.addArgument('--inversions', action = 'store_true', default = False)
		self.addArgument('--build-inversions', action = 'store_true', default = False)
		self.addArgument('--bubble-up', action = 'store_true', default = False)
		self.addArgument('--food-for-pm', action = 'store_true', default = False)
		self.addArgument('--ignore', action = 'append', default = [])
		self.addArgument('--output-directory', default = None)
		self.addArgument('--max-alternatives')
		self.parseArguments()

		self.verbosityLevel = 1
		if self.opts.terse:
			self.verbosityLevel = 0
		if self.opts.verbose:
			self.verbosityLevel = 2

	def performQueries(self):
		context = QueryContext(self)

		actions = []
		if self.opts.list:
			actions.append(ListQuery(context))
		if self.opts.requires:
			actions.append(RequiresQuery(context))
		if self.opts.what_requires:
			actions.append(WhatRequiresQuery(context, self.opts.what_requires))
		if self.opts.what_build_requires:
			actions.append(WhatBuildRequiresQuery(context, self.opts.what_build_requires))
		if self.opts.imports:
			actions.append(ImportedLabelsQuery(context))
		if self.opts.unclassified:
			actions.append(UnclassifiedQuery(context, self.opts.max_alternatives))
		if self.opts.inversions:
			actions.append(InversionsQuery(context, self.opts.ignore))
		if self.opts.build_inversions:
			actions.append(BuildInversionsQuery(context, self.opts.ignore))
		if self.opts.bubble_up:
			actions.append(BubbleUpQuery(context))
		if self.opts.food_for_pm:
			actions.append(FoodForPMQuery(context, self.opts.output_directory, ignore = self.opts.ignore))

		if len(actions) != 1:
			raise Exception(f"Expected exactly one action argument")

		for label in context.enumerateLabelsForQuery(self.opts.components):
			# print(f"Inspecting {label}")
			for ac in actions:
				ac(label)

def main():
	application = QueryApplication('query-component')
	application.performQueries()

class Renderer(object):
	def __init__(self, context):
		self.context = context

	@staticmethod
	def renderLabelSet(msg, labelSet):
		if not labelSet:
			return

		print(msg)
		for label in sorted(labelSet, key = str):
			print(f"     {label}")

class GenericQuery(object):
	def __init__(self, context, renderer = None):
		self.context = context
		self.renderer = renderer

class WhatRequiresRenderer(Renderer):
	def renderRequirementsReport(self, component, requirementsReport, requiredLabel):
		if not requirementsReport:
			print(f"   {component}: nothing requires {requiredLabel}")
		elif not requirementsReport.verbosityLevel:
			print(f"   {component}: the following topics require {requiredLabel}")
			for label in requirementsReport.minimalLabels:
				print(f"      {label}")
		else:
			print(f"   {component}: the following topics and packages require {requiredLabel}")
			self.renderRequirementsReportDetails(component, requirementsReport)

	def renderRequirementsReportDetails(self, component, requirementsReport):
		alreadyReported = Classification.createLabelSet()
		for label in requirementsReport.allLabels:
			packages = sorted(requirementsReport.packagesForLabel(label), key = str)
			if packages:
				print(f"      {label}")
				self.renderRequirementsForLabel(requirementsReport, label)
			elif label.parent in alreadyReported:
				pass
			elif self.context.getPackagesForLabel(label):
				print(f"      {label} (just label dependency)")
				self.renderRequirementsForLabel(requirementsReport, label)
			else:
				print(f"      {label} (empty label)")

			alreadyReported.add(label)

		dropAdvice = requirementsReport.dropRequirementsFrom
		if dropAdvice:
			print()
			print("      Consider dropping explicit requirements from the following label(s)")
			for label in sorted(dropAdvice, key = str):
				print(f"       - {label}")

	def renderRequirementsForLabel(self, requirementsReport, label):
		projection = set()

		tf = requirementsReport.subtreeForLabel(label)
		if tf is not None and requirementsReport.verbosityLevel >= 2:
			for prefix, topic in tf.render():

				s = f"{topic.componentName}:{topic}"
				if topic in requirementsReport.inspectLabelSet:
					s = tf.standout(s)
				print(f"          {prefix}{s}")

		packages = sorted(requirementsReport.packagesForLabel(label), key = str)
		if not packages:
			return

		for rpm in packages:
			print(f"         {rpm}")

			rpmReqs = requirementsReport.requirementsForRpm(rpm)
			if not rpmReqs:
				continue

			tf = rpmReqs.format()

			if requirementsReport.verbosityLevel < 2:
				for prefix, node in tf.render():
					if node.label:
						projection.add(node)
			else:
				for prefix, node in tf.render():
					if node.label is not None:
						print(f"          {prefix}{node.rpm} ({node.label})")
					else:
						print(f"          {prefix}{node.rpm}")

		if projection:
			print()
			print(f"        The following packages are used:")
			for node in sorted(projection, key = str):
				print(f"         {node.rpm} ({node.label})")
			print()

	def reportImportedPackages(self, component, label, pkgs):
		if not pkgs:
			return

		print()
		print(f"   {component} imports the following packages from {label} (component {label.componentName})")
		for rpm in pkgs:
			print(f"       - {rpm}")

class WhatRequiresQuery(GenericQuery):
	def __init__(self, context, what_requires, renderer = None):
		if renderer is None:
			renderer = WhatRequiresRenderer(context)
		super().__init__(context, renderer)
		self.what_requires = what_requires

	def __call__(self, queryTargetLabel):
		renderer = self.renderer
		context = self.context

		querySubject = QuerySubjectComponentOrTopic("what-requires", context, queryTargetLabel)

		for req in self.what_requires:
			topic = context.getLabel('label', req)

			if topic.type is Classification.TYPE_BINARY:
				inspectLabelSet = Classification.createLabelSet([topic])
			elif topic.type is Classification.TYPE_SOURCE:
				inspectLabelSet = context.getLabelsForComponent(topic)
			else:
				raise Exception(f"{self.__class__.__name__}: label type {topic.type} not supported")

			report = self.getTopicsRequiringLabelSet(querySubject, inspectLabelSet)

			renderer.renderRequirementsReport(queryTargetLabel, report, topic)

	def getTopicsRequiringLabelSet(self, querySubject, inspectLabelSet):
		verbosityLevel = self.context.verbosityLevel
		labelOrder = self.context.labelOrder

		result = RequirementsReport(self.context, inspectLabelSet, verbosityLevel = verbosityLevel)

		predicate = None
		if verbosityLevel:
			predicate = PackageRequiresLabelsPredicate(self.context.classification, inspectLabelSet)
			store = self.context.connectDatabase()

		inspectUpperCone = labelOrder.upwardClosureForSet(inspectLabelSet)
		for label in self.context.topDownTraversal(querySubject.binaryLabels):
			# skip over labels that are completely empty
			if not self.context.getPackagesForLabel(label):
				continue

			# hits is a convex set that includes the subtree that is limited by label above and
			# inspectLabelSet below.
			hits = labelOrder.downwardClosureFor(label).intersection(inspectUpperCone)
			if hits:
				result.add(label, hits)

				if verbosityLevel:
					for orpm in self.context.getPackagesForLabel(label):
						if orpm.isSynthetic:
							continue

						# Retrieve rpm dependencies from the DB
						rpm = store.recoverLatestPackageByName(orpm.name)

						if rpm is None:
							raise Exception(f"label {label} references {orpm} which is not in the DB")

						if predicate(rpm):
							result.addPackage(label, rpm, predicate)

					explicitRequirement = label.configuredRuntimeRequires.intersection(inspectLabelSet)
					if explicitRequirement and not result.packagesForLabel(label):
						result.adviseDropRequirements(label, explicitRequirement)

		return result

class WhatBuildRequiresRenderer(Renderer):
	def renderRequirementsReport(self, component, requirementsReport, requiredLabel):
		if not requirementsReport:
			print(f"   {component}: nothing requires {requiredLabel}")
		elif not requirementsReport.verbosityLevel:
			print(f"   {component}: the following packages buildrequire {requiredLabel}")
			for rpm in requirementsReport.allRequiredRpms:
				print(f"      {rpm}")
		else:
			print(f"   {component}: the following packages buildrequire {requiredLabel}")
			self.renderRequirementsReportDetails(component, requirementsReport)

	def renderRequirementsReportDetails(self, component, requirementsReport):
		if len(requirementsReport) <= 1:
			commonRpms = set()
		else:
			commonRpms = requirementsReport.commonRequiredRpms
			if commonRpms:
				print(f"     Packages required by all of the following builds:")
				self.renderPackages(commonRpms)
			print()

		verbosityLevel = self.context.verbosityLevel
		for obsBuild, requiredTopics, requiredRpms in requirementsReport.enumerate():
			if not requiredRpms:
				if verbosityLevel < 2:
					print(f"     {obsBuild} (only label dependency)")
				continue

			extraRpms = requiredRpms.difference(commonRpms)
			if not extraRpms:
				print(f"     {obsBuild} (only common packages)")
				continue

			print(f"     {obsBuild}:")

			if obsBuild.sources:
				srpm = obsBuild.sources[0]
				requirements = requirementsReport.requirementsForRpm(srpm)
				if requirements:
					tf = requirements.format()
					for prefix, node in tf.render():
						if node.label is not None:
							print(f"     {prefix}{node.rpm} ({node.label})")
						else:
							print(f"     {prefix}{node.rpm}")
					continue

			self.renderPackages(extraRpms)

		return

	def renderPackages(self, rpmSet):
		for rpm in sorted(rpmSet, key = lambda R: str(self.context.getLabelForPackage(R))):
			label = self.context.getLabelForPackage(rpm)
			print(f"       {rpm} ({label.componentName}:{label})")

class WhatBuildRequiresQuery(GenericQuery):
	def __init__(self, context, what_requires, renderer = None):
		if renderer is None:
			renderer = WhatBuildRequiresRenderer(context)
		super().__init__(context, renderer)
		self.what_requires = what_requires

	def __call__(self, queryTargetLabel):
		renderer = self.renderer
		context = self.context

		querySubject = QuerySubjectComponentOrTopic("what-build-requires", context, queryTargetLabel)

		for req in self.what_requires:
			topic = context.getLabel('label', req)

			if topic.type is Classification.TYPE_BINARY:
				inspectLabelSet = Classification.createLabelSet([topic])
			elif topic.type is Classification.TYPE_SOURCE:
				inspectLabelSet = context.getLabelsForComponent(topic)
			else:
				raise Exception(f"{self.__class__.__name__}: label type {topic.type} not supported")

			report = self.getTopicsRequiringLabelSet(querySubject, inspectLabelSet)

			renderer.renderRequirementsReport(queryTargetLabel, report, topic)

	def getTopicsRequiringLabelSet(self, querySubject, inspectLabelSet):
		verbosityLevel = self.context.verbosityLevel
		labelOrder = self.context.labelOrder

		result = BuildRequirementsReport(self.context, inspectLabelSet, verbosityLevel = verbosityLevel)

		predicate = None
		if verbosityLevel:
			predicate = PackageRequiresLabelsPredicate(self.context.classification, inspectLabelSet)
			store = self.context.connectDatabase()

		obsBuilds = set()
		for label in querySubject.binaryLabels:
			for rpm in self.context.getPackagesForLabel(label, fromDB = True):
				build = self.context.getBuildForPackage(rpm)
				if build is None:
					raise Exception(f"unable to find an OBS build for {rpm} ({label})")
				obsBuilds.add(build)

		labelOrder = self.context.labelOrder
		inspectUpperCone = labelOrder.upwardClosureForSet(inspectLabelSet)

		for obsBuild in sorted(obsBuilds, key = str):
			requiredTopics = Classification.createLabelSet()
			requiredRpms = set()
			for rpm, requiredLabel in self.context.enumerateBuildRequirements(obsBuild):
				if requiredLabel in inspectUpperCone:
					requiredTopics.update(inspectLabelSet.intersection(labelOrder.downwardClosureFor(requiredLabel)))
				if requiredLabel in inspectLabelSet:
					requiredRpms.add(rpm)

			if predicate and obsBuild.sources:
				assert(len(obsBuild.sources) == 1)
				srpm = obsBuild.sources[0]
				if predicate(srpm):
					result.addPackageRequirements(predicate, srpm)

			if requiredTopics:
				result.add(obsBuild, requiredRpms, requiredTopics)

		return result


class APIRenderer(Renderer):
	def __init__(self):
		self.renderPurposes = False

	def renderHeader(self, component, querySubject):
		pass

	def renderTrailer(self, component, querySubject):
		pass

	def renderImportedAPIs(self, importer, apis, indent):
		pass

	def renderWildImports(self, importer, apis, indent):
		pass

class APITextRenderer(APIRenderer):
	def renderHeader(self, component, querySubject):
		self.renderImportedAPIs(component, querySubject.alwaysImportedAPIs, 0)

	def renderImportedAPIs(self, importer, apis, indent):
		ws = indent * " "
		self.renderLabelSet(f"{ws}{importer} imports the following APIs:", apis)

	def renderWildImports(self, importer, apis, indent):
		ws = indent * " "
		self.renderLabelSet(f"{ws}{importer} uses the following non-APIs:", apis)

class APISummarizer(APIRenderer):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)
		self._summary = {}

	def renderImportedAPIs(self, importer, apis, indent):
		for label in apis:
			try:
				self._summary[label] += 1
			except:
				self._summary[label] = 1

	def renderWildImports(self, importer, apis, indent):
		pass

	def renderTrailer(self, component, querySubject):
		print(f"{component} imports the following APIs")
		for label, count in sorted(self._summary.items(), key = str):
			print(f" {count:5} {label}")

class ImportedLabelsQuery(GenericQuery):
	def __init__(self, context):
		if context.verbosityLevel == 0:
			renderer = APISummarizer()
		else:
			renderer = APITextRenderer()

		super().__init__(context, renderer)

	def __call__(self, queryTargetLabel):
		context = self.context
		renderer = self.renderer

		querySubject = QuerySubjectComponent("imports", context, queryTargetLabel)

		renderer.renderHeader(queryTargetLabel, querySubject)
		for topic in context.bottomUpTraversal(querySubject.binaryLabels):
			if topic.parent is None:
				self.inspectTopic(querySubject, topic, renderer)

		# FIXME: inspect the component's build configs and check what they import

		renderer.renderTrailer(queryTargetLabel, querySubject)

	# topic is a requirement of some label that's part of component
	def inspectTopic(self, querySubject, topic, renderer):
		visitor = self.Visitor(querySubject, topic)

		visitor.render(renderer)

		if renderer.renderPurposes:
			for purpose in topic.objectPurposes:
				purposeVisitor = visitor.descend(purpose)
				purposeVisitor.render(renderer)

		for flavor in topic.flavors:
			flavorVisitor = visitor.descend(flavor)
			flavorVisitor.render(renderer)

			if renderer.renderPurposes:
				for purpose in flavor.objectPurposes:
					purposeVisitor = flavorVisitor.descend(purpose)
					purposeVisitor.render(renderer)
		return


	class Visitor:
		def __init__(self, querySubject, label, parent = None):
			self.querySubject = querySubject
			self.label = label

			if parent:
				subtractAPIs = parent.maskAPIs
				self.indent = parent.indent + 1
			else:
				subtractAPIs = None
				self.indent = 1

			context = querySubject.context
			labelOrder = context.labelOrder

			requiredLabels = labelOrder.downwardClosureFor(label)

			if label.purposeName:
				if subtractAPIs:
					subtractAPIs = subtractAPIs.union(self.derivePurposeAPIs(label.purposeName, subtractAPIs))
				else:
					subtractAPIs = self.derivePurposeAPIs(label.purposeName, querySubject.accessibleAPIs)

			if subtractAPIs:
				requiredLabels = requiredLabels.difference(subtractAPIs)

			self.importedAPIs = requiredLabels.intersection(querySubject.importableAPIs)
			self.importedAPIs.difference_update(querySubject.alwaysImportedAPIs)

			wildImports = requiredLabels.difference(context._allAPIs).difference(querySubject.accessibleAPIs)
			if label.purposeName and wildImports:
				wildImports.difference_update(self.derivePurposeAPIs(label.purposeName, querySubject.importableAPIs))
			if wildImports:
				wildImports = labelOrder.maxima(wildImports)
			self.wildImports = wildImports

			self.maskAPIs = self.importedAPIs.union(wildImports)
			if subtractAPIs:
				self.maskAPIs.update(subtractAPIs)
			self.maskAPIs.add(label)
			self.maskAPIs = labelOrder.downwardClosureForSet(self.maskAPIs)

		def derivePurposeAPIs(self, purposeName, labelSet):
			# for a label like @Foo-32bit, we allow access to any @BlahAPI-32bit
			return Classification.createLabelSet(
					filter(bool,
						map(lambda _: _.getObjectPurpose(purposeName), labelSet)
						))

		def render(self, renderer):
			renderer.renderImportedAPIs(self.label, self.importedAPIs, 1)
			if self.wildImports:
				renderer.renderWildImports(self.label, self.wildImports, 1)

		def descend(self, label):
			return self.__class__(self.querySubject, label, parent = self)


class UnclassifiedQuery(GenericQuery):
	def __init__(self, context, maxAlternatives):
		if maxAlternatives in (None, '', 'any'):
			maxAlternatives = None
		else:
			maxAlternatives = int(maxAlternatives)

		renderer = UnclassifiedRenderer(context, maxAlternatives)
		super().__init__(context, renderer)

	def __call__(self, queryTargetLabel):
		unsorted = list(self.context.getUnclassifiedForComponent(queryTargetLabel))

		renderer = self.renderer
		for rpm, numOther in sorted(unsorted, key = (lambda pair: (pair[1], pair[0].name))):
			renderer.renderCandidate(rpm, numOther)

class UnclassifiedRenderer(Renderer):
	def __init__(self, context, maxAlternatives):
		self.maxAlternatives = maxAlternatives

	def renderCandidate(self, rpm, numOther):
		if self.maxAlternatives is not None and numOther > self.maxAlternatives:
			return

		if numOther == 0:
			print(f"  {rpm}")
		elif numOther == QueryContext.QUASI_INFINITE:
			print(f"  {rpm} - anywhere")
		else:
			print(f"  {rpm} - {numOther} alternatives")

class InversionsRenderer(WhatRequiresRenderer):
	def renderRequirementsReport(self, component, requirementsReport):
		if not requirementsReport:
			print(f"   {component}: no inversions")
		elif not requirementsReport.verbosityLevel:
			print(f"   {component}: the following topics have inversions")
			for label in requirementsReport.minimalLabels:
				print(f"      {label}")
		else:
			print(f"   {component}: the following topics and packages have inversions")
			self.renderRequirementsReportDetails(component, requirementsReport)

class InversionsQueryMixin(object):
	def __init__(self, context, ignore):
		opts = context.application.opts

		topicOrder = context.labelOrder
		componentOrder = context.componentOrder

		visibleComponents = Classification.createLabelSet()
		for componentLabel in context.enumerateLabelsForQuery(opts.components):
			if componentLabel.type is Classification.TYPE_BINARY:
				assert(componentLabel.sourceProject is not None)
				componentLabel = componentLabel.sourceProject
			visibleComponents.update(componentOrder.downwardClosureFor(componentLabel))

		visibleTopics = Classification.createLabelSet()
		for componentLabel in visibleComponents:
			topics = context.getLabelsForComponent(componentLabel)
			visibleTopics.update(topics)

		ignoredTopics = Classification.createLabelSet()
		for labelName in ignore:
			ignoreLabel = context.getLabel('--ignore label', labelName, Classification.TYPE_BINARY)
			ignoredTopics.add(ignoreLabel)
			for purpose in ignoreLabel.objectPurposes:
				ignoredTopics.add(purpose)

		ignoredTopics = topicOrder.downwardClosureForSet(ignoredTopics).difference(visibleTopics)
		if ignoredTopics:
			print(f"The following topic labels are considered \"good\" in this query:")
			for topic in sorted(ignoredTopics, key = str):
				print(f" - {topic.componentName}:{topic}")
			print()

		visibleTopics.update(ignoredTopics)

		self.inversionLabels = context.allBinaryLabels.difference(visibleTopics)

class InversionsQuery(WhatRequiresQuery, InversionsQueryMixin):
	def __init__(self, context, ignore):
		renderer = InversionsRenderer(context)
		super().__init__(context, [], renderer = renderer)

		InversionsQueryMixin.__init__(self, context, ignore)

	def __call__(self, queryTargetLabel):
		renderer = self.renderer
		context = self.context

		querySubject = QuerySubjectComponentOrTopic("inversions", context, queryTargetLabel)

		report = self.getTopicsRequiringLabelSet(querySubject, self.inversionLabels)
		renderer.renderRequirementsReport(queryTargetLabel, report)

class InversionRenderer(Renderer):
	def __init__(self, context):
		self.context = context
		self.indexFormatter = IndexFormatterTwoLevels()

	def render(self, componentName, invTopic, requiredBy):
		inversionName = f"{self.renderTopic(invTopic)} required by:"
		for label in requiredBy:
			packageCount = self.context.getPackageCountForLabel(label)
			self.indexFormatter.next(componentName, inversionName, self.renderTopic(label))

	def renderTopic(self, label):
		packageCount = self.context.getPackageCountForLabel(label)
		return f"{label} ({packageCount} packages)"

class BuildInversionsQuery(GenericQuery, InversionsQueryMixin):
	def __init__(self, context, ignore, renderer = None):
		if renderer is None:
			renderer = BuildInversionsRenderer(context)

		super().__init__(context, renderer)
		InversionsQueryMixin.__init__(self, context, ignore)

	def __call__(self, queryTargetLabel):
		renderer = self.renderer
		context = self.context

		querySubject = QuerySubjectComponentOrTopic("inversions", context, queryTargetLabel)

		report = self.getTopicsRequiringLabelSet(querySubject, self.inversionLabels)
		renderer.renderRequirementsReport(queryTargetLabel, report)
		return
		renderer = self.renderer
		context = self.context

		querySubject = QuerySubjectComponentOrTopic("what-build-requires", context, queryTargetLabel)

		for req in self.what_requires:
			topic = context.getLabel('label', req)

			if topic.type is Classification.TYPE_BINARY:
				inspectLabelSet = Classification.createLabelSet([topic])
			elif topic.type is Classification.TYPE_SOURCE:
				inspectLabelSet = context.getLabelsForComponent(topic)
			else:
				raise Exception(f"{self.__class__.__name__}: label type {topic.type} not supported")

			report = self.getTopicsRequiringLabelSet(querySubject, inspectLabelSet)

			renderer.renderRequirementsReport(queryTargetLabel, report, topic)

	def getTopicsRequiringLabelSet(self, querySubject, inspectLabelSet):
		verbosityLevel = self.context.verbosityLevel
		labelOrder = self.context.labelOrder

		result = BuildRequirementsReport(self.context, inspectLabelSet, verbosityLevel = verbosityLevel)

		predicate = None
		if verbosityLevel:
			predicate = PackageRequiresLabelsPredicate(self.context.classification, inspectLabelSet)
			store = self.context.connectDatabase()

		obsBuilds = set()
		for label in querySubject.binaryLabels:
			for rpm in self.context.getPackagesForLabel(label, fromDB = True):
				build = self.context.getBuildForPackage(rpm)
				if build is None:
					raise Exception(f"unable to find an OBS build for {rpm} ({label})")
				obsBuilds.add(build)

		labelOrder = self.context.labelOrder
		inspectUpperCone = labelOrder.upwardClosureForSet(inspectLabelSet)

		for obsBuild in sorted(obsBuilds, key = str):
			requiredTopics = Classification.createLabelSet()
			requiredRpms = set()
			for rpm, requiredLabel in self.context.enumerateBuildRequirements(obsBuild):
				if requiredLabel in inspectUpperCone:
					requiredTopics.update(inspectLabelSet.intersection(labelOrder.downwardClosureFor(requiredLabel)))
				if requiredLabel in inspectLabelSet:
					requiredRpms.add(rpm)

			if predicate and obsBuild.sources:
				assert(len(obsBuild.sources) == 1)
				srpm = obsBuild.sources[0]
				if predicate(srpm):
					result.addPackageRequirements(predicate, srpm)

			if requiredTopics:
				result.add(obsBuild, requiredRpms, requiredTopics)

		return result

class BuildInversionsRenderer(WhatBuildRequiresRenderer):
	def renderRequirementsReport(self, component, requirementsReport):
		if not requirementsReport:
			print(f"   {component}: no build inversions")
		elif not requirementsReport.verbosityLevel:
			print(f"   {component}: the following topics have build inversions")
			for label in requirementsReport.minimalLabels:
				print(f"      {label}")
		else:
			print(f"   {component}: the following topics and packages have build inversions")
			self.renderRequirementsReportDetails(component, requirementsReport)

class BubbleUpQuery(GenericQuery):
	def __init__(self, context):
		super().__init__(context, None)

	def __call__(self, queryTargetLabel):
		store = self.context.connectDatabase()

		rpmToBuildMap = {}
		for build in self.context.getBuildsForComponent(queryTargetLabel):
			for orpm in build.binaries:
				if orpm.isSynthetic:
					continue
				rpm = store.recoverLatestPackageByName(orpm.name)
				if rpm is None:
					raise Exception(f"build {build} references {orpm} which is not in the DB")
				rpmToBuildMap[rpm] = build
		print(f"{queryTargetLabel} contains {len(rpmToBuildMap)} rpms")

		dominationMatrix = self.DominationMatrix()
		for rpm, build in rpmToBuildMap.items():
			for req in rpm.enumerateRequiredRpms():
				dominatedBuild = rpmToBuildMap.get(req)
				if dominatedBuild is None:
					continue
				if dominatedBuild is build:
					continue

				dominationMatrix.add(build, dominatedBuild)

		for build in self.context.getBuildsForComponent(queryTargetLabel):
			dominatedBy = dominationMatrix.get(build)
			if not dominatedBy:
				print(f"   {build}")

	class DominationMatrix(object):
		def __init__(self):
			self.dominatedBy = {}

		def add(self, dominatingBuild, dominatedBuild):
			dset = self.dominatedBy.get(dominatedBuild)
			if dset is None:
				dset = set()
				self.dominatedBy[dominatedBuild] = dset
			dset.add(dominatingBuild)

		def get(self, build):
			return self.dominatedBy.get(build)

class ListQuery(GenericQuery):
	def __init__(self, context, onlyBaseLabels = None):
		super().__init__(context, None)

		classification = context.classification
		membershipSizes = CountingDict()

		if onlyBaseLabels is None and context.verbosityLevel < 2:
			onlyBaseLabels = True

		for label, members in classification.enumeratePackages():
			if onlyBaseLabels:
				label = label.baseLabel
			membershipSizes.increment(label, len(members))

		for label, build in classification.enumerateBuilds():
			membershipSizes.increment(label, 1)

		self._membershipSizes = membershipSizes

	def __call__(self, queryTargetLabel):
		# stats = self.getComponentStats(queryTargetLabel)

		if queryTargetLabel.type is Classification.TYPE_BINARY:
			self.processTopic(queryTargetLabel)
			return

		size = self._membershipSizes[queryTargetLabel]
		print(f"  {queryTargetLabel} ({size} OBS packages)")

		verbosityLevel = self.context.verbosityLevel
		if verbosityLevel > 0:
			classificationScheme = self.context.classificationScheme
			topicOrder = self.context.labelOrder

			binaryLabels = classificationScheme.getReferencingLabels(queryTargetLabel)
			for label in topicOrder.bottomUpTraversal(binaryLabels):
				self.processTopic(label)

			print()
		return

	def processTopic(self, label):
		size = self._membershipSizes[label]
		if not size:
			return

		print(f"      - {label} ({size} rpms)")
		if self.context.verbosityLevel > 1:
			classification = self.context.classification
			for rpm in sorted(classification.getPackagesForLabel(label), key = str):
				print(f"          {rpm}")

class RequiresQuery(GenericQuery):
	def __init__(self, context, onlyBaseLabels = None):
		super().__init__(context, None)

		classification = context.classification
		membershipSizes = CountingDict()

		self._membershipSizes = membershipSizes

	def __call__(self, queryTargetLabel):
		if queryTargetLabel.type is Classification.TYPE_BINARY:
			not_implemented
			return

		topicOrder = self.context.labelOrder
		classificationScheme = self.context.classificationScheme

		if self.context.verbosityLevel <= 1:
			binaryLabels = classificationScheme.getReferencingLabels(queryTargetLabel)

			reqs = Classification.createLabelSet()
			for topic in binaryLabels:
				reqs.update(topicOrder.lowerNeighbors(topic))
			binaryLabels.update(reqs)

			tf = topicOrder.asTreeFormatter(binaryLabels, topDown = True)
		else:
			binaryLabels = classificationScheme.getReferencingLabels(queryTargetLabel)
			binaryLabels = topicOrder.downwardClosureForSet(binaryLabels)
			tf = topicOrder.asTreeFormatter(binaryLabels, topDown = True)

		print(f"  {queryTargetLabel}")
		for prefix, label in tf.render():
			if label.sourceProject is not queryTargetLabel:
				print(f" {prefix}{label} [{label.sourceProject}]")
			else:
				print(f" {prefix}{label}")
		print()
		return

class FoodForPMQuery(GenericQuery):
	def __init__(self, context, outputPath = None, ignore = []):
		super().__init__(context, None)
		self.outputPath = outputPath
		self.once = False

		self.ignore = None
		if ignore is not None:
			self.ignore = Classification.createLabelSet()
			for name in ignore:
				label = context.getLabel('ignored label', name)
				if label.type is Classification.TYPE_BINARY:
					self.ignore.add(label)
				elif label.type is Classification.TYPE_SOURCE:
					self.ignore.update(context.getLabelsForComponent(label))
				else:
					raise Exception(f"Cannot ignore label {name} - unsupported type {label.type}")

		self._packageTopicsWritten = Classification.createLabelSet()

	def __call__(self, queryTargetLabel):
		if self.once:
			return
		self.once = True

		context = self.context
		topicOrder = context.labelOrder
		allTopics = context.allBinaryLabels

		# we only ever look at base labels
		baseTopics = Classification.createLabelSet()
		topicPackageCount = CountingDict()
		baseTopicClosure = {}
		for topic in allTopics:
			baseLabel = topic.baseLabel
			baseTopics.add(baseLabel)

			count = len(context.classification.getPackagesForLabel(topic))
			topicPackageCount.increment(baseLabel, count)

			closure = baseTopicClosure.get(baseLabel)
			if closure is None:
				closure = Classification.createLabelSet()
				baseTopicClosure[baseLabel] = closure
			closure.update(topicOrder.downwardClosureFor(topic))

		# ignore any topics that exist just as a handle (like @SystemPythonCore is a front for @Python311)
		empty = Classification.createLabelSet(filter(lambda topic: not topicPackageCount[topic], baseTopics))
		baseTopics.difference_update(empty)

		apiTopics = Classification.createLabelSet(filter(lambda L: L.isAPI, allTopics))

		allTopics = baseTopics.difference(apiTopics)

		firstLevelTopics = topicOrder.maxima(allTopics)

		firstLevelTopicsClosure = topicOrder.upwardClosureForSet(firstLevelTopics)
		secondLevelTopics = topicOrder.maxima(allTopics.difference(firstLevelTopicsClosure))

		if self.ignore:
			firstLevelTopics.difference_update(self.ignore)
			secondLevelTopics.difference_update(self.ignore)

		csv = None

		print(f"First level topics")
		if self.outputPath is not None:
			csv = CSVWriter(self.outputPath + "/firstlevel.csv", ['component', 'topic'])

		for topic in self.sortedTopics(firstLevelTopics):
			print(f"   {topic.componentName}:{topic}")
			if csv:
				csv.write((topic.componentName, topic.name))

		print(f"Second level topics")
		if self.outputPath is not None:
			csv = CSVWriter(self.outputPath + "/secondlevel.csv", ['component', 'topic', 'required by'])

		for topic in self.sortedTopics(secondLevelTopics):
			print(f"   {topic.componentName}:{topic} required by:")
			for upper in self.dominatingLabels(topic):
				print(f"     {upper.componentName}:{upper}")
				if csv:
					csv.write((topic.componentName, topic.name, upper.name))

		if self.outputPath is not None:
			csv = CSVWriter(self.outputPath + "/packages.csv", ['component', 'topic', 'package'])
			for topic in firstLevelTopics:
				self.writePackagesForTopic(topic, csv)
			for topic in secondLevelTopics:
				self.writePackagesForTopic(topic, csv)

	def sortedTopics(self, topics):
		def sortkey(label):
			return (label.componentName, label.name)
		return sorted(topics, key = sortkey)

	def dominatingLabels(self, topic):
		topicOrder = self.context.labelOrder

		result = Classification.createLabelSet()
		for label in topicOrder.upperNeighbors(topic):
			label = label.baseLabel
			if label is topic:
				continue
			# this doesn't work right now because we don't store the "is api for" relation in
			# the XML file generated by the labelling run
			if label is topic.correspondingAPI:
				continue

			# what we do instead is we hide all API labels at this point
			if label.isAPI:
				continue

			result.add(label)

		return result

	def writePackagesForTopic(self, topic, csv):
		context = self.context
		topicOrder = context.labelOrder

		topicClosure = topicOrder.upwardClosureFor(topic).difference(self._packageTopicsWritten)
		self._packageTopicsWritten.update(topicClosure)

		packages = set()
		for rpm in context.classification.getPackagesForLabel(topic):
			for sib in context.getSiblingsForPackage(rpm):
				if context.getLabelForPackage(sib) in topicClosure:
					packages.add(sib)

		for rpm in packages:
			csv.write((topic.componentName, topic.name, rpm.shortname))

main()
